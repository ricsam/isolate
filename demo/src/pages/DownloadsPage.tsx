import { useState, useRef } from "react";

type FileType = "text" | "random";

interface DownloadState {
  downloading: boolean;
  progress: number;
  speed: string;
  error: string | null;
}

export function DownloadsPage() {
  const [fileType, setFileType] = useState<FileType>("text");
  const [fileSize, setFileSize] = useState(1024 * 100); // 100KB default
  const [state, setState] = useState<DownloadState>({
    downloading: false,
    progress: 0,
    speed: "",
    error: null,
  });
  const abortRef = useRef<AbortController | null>(null);

  const formatSize = (bytes: number): string => {
    if (bytes >= 1024 * 1024) {
      return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
    }
    return `${(bytes / 1024).toFixed(0)} KB`;
  };

  const handleDownload = async () => {
    setState({ downloading: true, progress: 0, speed: "", error: null });
    abortRef.current = new AbortController();
    const startTime = Date.now();

    try {
      const response = await fetch(
        `/api/downloads/generate?type=${fileType}&size=${fileSize}`,
        { signal: abortRef.current.signal }
      );

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const contentLength = parseInt(
        response.headers.get("Content-Length") || "0"
      );
      const reader = response.body!.getReader();
      const chunks: Uint8Array[] = [];
      let receivedLength = 0;
      let lastUpdate = startTime;
      let lastBytes = 0;

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        chunks.push(value);
        receivedLength += value.length;

        const progress = contentLength
          ? Math.round((receivedLength / contentLength) * 100)
          : 0;

        // Calculate speed every 200ms
        const now = Date.now();
        if (now - lastUpdate >= 200) {
          const bytesPerSecond =
            ((receivedLength - lastBytes) / (now - lastUpdate)) * 1000;
          const speed =
            bytesPerSecond >= 1024 * 1024
              ? `${(bytesPerSecond / (1024 * 1024)).toFixed(1)} MB/s`
              : `${(bytesPerSecond / 1024).toFixed(0)} KB/s`;

          setState((prev) => ({ ...prev, progress, speed }));
          lastUpdate = now;
          lastBytes = receivedLength;
        } else {
          setState((prev) => ({ ...prev, progress }));
        }
      }

      // Create blob and download
      const blob = new Blob(chunks as BlobPart[]);
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download =
        fileType === "random" ? "random-data.bin" : "generated-text.txt";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      setState((prev) => ({
        ...prev,
        downloading: false,
        progress: 100,
        speed: "",
      }));
    } catch (err) {
      if ((err as Error).name !== "AbortError") {
        setState((prev) => ({
          ...prev,
          downloading: false,
          error: (err as Error).message,
        }));
      } else {
        setState((prev) => ({
          ...prev,
          downloading: false,
          progress: 0,
          speed: "",
        }));
      }
    } finally {
      abortRef.current = null;
    }
  };

  const handleCancel = () => {
    abortRef.current?.abort();
  };

  const sizeOptions = [
    { value: 1024 * 10, label: "10 KB" },
    { value: 1024 * 100, label: "100 KB" },
    { value: 1024 * 1024, label: "1 MB" },
    { value: 1024 * 1024 * 5, label: "5 MB" },
  ];

  return (
    <div className="page downloads-page">
      <h1>File Downloads</h1>
      <p>Streaming file downloads generated by QuickJS</p>

      <div className="download-options">
        <div className="option-group">
          <label>File Type</label>
          <select
            value={fileType}
            onChange={(e) => setFileType(e.target.value as FileType)}
            disabled={state.downloading}
            className="option-select"
          >
            <option value="text">Text File (Lorem ipsum)</option>
            <option value="random">Random Binary Data</option>
          </select>
        </div>

        <div className="option-group">
          <label>File Size</label>
          <select
            value={fileSize}
            onChange={(e) => setFileSize(parseInt(e.target.value))}
            disabled={state.downloading}
            className="option-select"
          >
            {sizeOptions.map((opt) => (
              <option key={opt.value} value={opt.value}>
                {opt.label}
              </option>
            ))}
          </select>
        </div>

        <div className="button-group">
          {!state.downloading ? (
            <button onClick={handleDownload} className="download-button">
              Generate & Download
            </button>
          ) : (
            <button onClick={handleCancel} className="cancel-button">
              Cancel
            </button>
          )}
        </div>
      </div>

      {state.error && <div className="error-message">{state.error}</div>}

      {(state.downloading || state.progress > 0) && (
        <div className="progress-section">
          <div className="progress-info">
            <span>
              {state.downloading ? "Downloading..." : "Complete!"}
            </span>
            <span>
              {state.progress}% ({formatSize((fileSize * state.progress) / 100)}{" "}
              / {formatSize(fileSize)})
            </span>
            {state.speed && <span className="speed">{state.speed}</span>}
          </div>
          <div className="progress-bar">
            <div
              className="progress-fill"
              style={{ width: `${state.progress}%` }}
            />
          </div>
        </div>
      )}

      <div className="info-section">
        <h3>How it works</h3>
        <p>
          This demo generates files on-the-fly inside QuickJS using a
          ReadableStream. The server streams chunks progressively, allowing you
          to see the download progress in real-time.
        </p>
        <ul>
          <li>
            <strong>Text files</strong> contain numbered lines of Lorem ipsum
            text
          </li>
          <li>
            <strong>Random files</strong> contain cryptographically random bytes
          </li>
          <li>Files are generated in 4KB chunks with small delays</li>
          <li>Maximum file size is 10MB</li>
        </ul>
      </div>
    </div>
  );
}
