/**
 * Build script for Library Type Bundles
 *
 * Scans node_modules for zod and @richie-rpc/* type definitions
 * and bundles them into library-types.ts as string constants.
 *
 * Run from demo directory: cd demo && bun scripts/build-library-types.ts
 * Or from root: bun demo/scripts/build-library-types.ts
 */
import { writeFileSync, existsSync } from "node:fs";
import { join, dirname } from "node:path";

interface PackageTypeFile {
  path: string; // e.g., "./node_modules/zod/v4/core/api.d.ts"
  virtualPath: string; // e.g., "node_modules/zod/v4/core/api.d.ts"
}

interface PackageTypes {
  name: string; // e.g., "zod"
  files: PackageTypeFile[];
}

// Resolve node_modules - packages are hoisted to the root in npm workspaces
const demoDir = dirname(import.meta.dir);
const rootDir = dirname(demoDir);
const nodeModulesPath = join(rootDir, "node_modules");
console.log(`Looking for packages in: ${nodeModulesPath}`);

async function collectPackageTypes(
  packageName: string
): Promise<PackageTypes> {
  const packagePath = join(nodeModulesPath, packageName);
  const files: PackageTypeFile[] = [];

  // Add package.json
  const pkgJsonPath = join(packagePath, "package.json");
  if (existsSync(pkgJsonPath)) {
    files.push({
      path: pkgJsonPath,
      virtualPath: `node_modules/${packageName}/package.json`,
    });
  }

  // Collect .d.ts, .d.cts, .d.mts files
  for (const ext of ["d.ts", "d.cts", "d.mts"]) {
    const glob = new Bun.Glob(`**/*.${ext}`);
    for await (const filePath of glob.scan(packagePath)) {
      const fullPath = join(packagePath, filePath);
      const virtualPath = `node_modules/${packageName}/${filePath}`;
      files.push({ path: fullPath, virtualPath });
    }
  }

  return { name: packageName, files };
}

async function buildLibraryTypes() {
  console.log("Building library types bundle...\n");

  // Collect types for each package
  const zodTypes = await collectPackageTypes("zod");
  console.log(`zod: ${zodTypes.files.length} files`);

  const richieCore = await collectPackageTypes("@richie-rpc/core");
  console.log(`@richie-rpc/core: ${richieCore.files.length} files`);

  const richieServer = await collectPackageTypes("@richie-rpc/server");
  console.log(`@richie-rpc/server: ${richieServer.files.length} files`);

  // Build the bundle structure
  const allPackages = [zodTypes, richieCore, richieServer];
  const bundle: Record<
    string,
    { files: Array<{ content: string; path: string }> }
  > = {};

  for (const pkg of allPackages) {
    bundle[pkg.name] = { files: [] };
    for (const typeFile of pkg.files) {
      const file = Bun.file(typeFile.path);
      if (await file.exists()) {
        bundle[pkg.name].files.push({
          content: await file.text(),
          path: typeFile.virtualPath,
        });
      }
    }
  }

  // Generate TypeScript source file
  const output = `/**
 * Auto-generated library type definitions for isolate typechecking
 * Generated by: bun demo/scripts/build-library-types.ts
 * DO NOT EDIT MANUALLY
 */

import type { LibraryTypes } from "@ricsam/isolate-types";

export const LIBRARY_TYPES: Record<string, LibraryTypes> = ${JSON.stringify(bundle, null, 2)};
`;

  const outputPath = join(demoDir, "src", "library-types.ts");
  writeFileSync(outputPath, output);

  console.log(`\nâœ“ Written to: ${outputPath}`);
  console.log(`  Total size: ${(output.length / 1024).toFixed(2)} KB`);
}

buildLibraryTypes().catch(console.error);
